
# 레벨 0

1. **컴퓨터 시스템에서 CPU, RAM, 저장 장치의 역할과 이들이 어떻게 상호 작용하는지 설명해주세요.**
```aiignore
컴퓨터 시스템 핵심 구성 요소의 역할과 상호작용은 다음과 같습니다:
CPU: 컴퓨터의 두뇌로, 모든 연산과 명령어 처리를 담당합니다.
RAM: 실행 중인 프로그램과 데이터를 임시 저장하는 휘발성 메모리입니다. CPU가 빠르게 접근할 수 있습니다.
저장 장치: 앱, 운영체제, 사용자 데이터를 영구적으로 보관하는 비휘발성 메모리입니다.
상호작용:

프로그램 실행 시 저장 장치에서 RAM으로 데이터가 로드됩니다.
CPU는 RAM에서 명령어와 데이터를 읽어 처리합니다.
처리 결과는 RAM에 임시 저장되고, 필요시 저장 장치에 영구 저장됩니다.
```

- CPU와 메모리 간의 데이터 교환은 어떻게 이루어지나요?
```aiignore
CPU와 메모리 간의 데이터 교환은 시스템 버스를 통해 이루어집니다. 시스템 버스는 다음 세 가지로 구성됩니다:

주소 버스: CPU가 접근할 메모리 위치를 지정합니다.
데이터 버스: 실제 데이터가 양방향으로 전송되는 경로입니다.
제어 버스: 읽기/쓰기 신호를 전달하여 데이터 전송을 제어합니다.

읽기 과정은 CPU가 주소를 지정하고 읽기 신호를 보내면, 메모리가 해당 데이터를 CPU로 전송합니다. 쓰기 과정은 CPU가 주소와 데이터를 보내고 쓰기 신호를 전달하면, 메모리가 해당 위치에 데이터를 저장합니다.
```
- 버스(Bus)란 무엇이며, 어떤 종류가 있나요?
```aiignore
버스(Bus)는 컴퓨터 시스템 내에서 데이터와 신호를 전송하는 통로입니다. 주요 종류는 다음과 같습니다:

시스템 버스: CPU와 주변 장치를 연결하는 주요 통로로 세 가지로 구성됩니다:

주소 버스: 데이터의 출발지와 목적지 주소를 전달합니다.
데이터 버스: 실제 데이터가 전송되는 양방향 경로입니다.
제어 버스: 읽기/쓰기 신호 등 데이터 전송 제어 신호를 전달합니다.


확장 버스: PCI, PCI Express 등 추가 장치 연결을 위한 버스입니다.
외부 버스: USB, SATA 등 외부 장치와 통신하기 위한 버스입니다.
```

2. **캐시 메모리의 개념과 역할에 대해 설명해주세요.**
```aiignore
캐시 메모리는 CPU와 주 메모리(RAM) 사이에 위치한 고속 임시 저장소입니다.
개념:

CPU가 자주 접근하는 데이터와 명령어를 저장하는 소용량 고속 메모리입니다.
CPU에 직접 내장되거나 근접하게 위치하여 접근 속도가 RAM보다 훨씬 빠릅니다.
보통 여러 계층(L1, L2, L3)으로 구성되며, L1이 가장 빠르고 용량이 작습니다.

역할:

메모리 접근 속도 차이(Memory Gap)를 줄여 CPU 성능을 향상시킵니다.
자주 사용되는 데이터를 미리 가져와(prefetch) 저장하여 CPU 대기 시간을 줄입니다.
시간적 지역성(동일 데이터 재사용)과 공간적 지역성(인접 데이터 사용) 원리를 활용합니다.
캐시 히트(hit)가 발생하면 RAM 접근 없이 빠른 처리가 가능하며, 미스(miss)가 발생하면 RAM에서 데이터를 로드합니다.
```

- 캐시의 지역성(Locality) 원리에 대해 설명해주세요.
```aiignore
캐시의 지역성(Locality) 원리는 프로그램 실행 시 데이터 접근 패턴에 관한 특성으로, 크게 두 가지로 나뉩니다:
시간적 지역성(Temporal Locality):

최근에 접근한 데이터는 가까운 미래에 다시 접근될 가능성이 높다는 원리입니다.
예: 반복문에서 같은 변수를 여러 번 사용하는 경우, 해당 변수는 캐시에 유지됩니다.

공간적 지역성(Spatial Locality):

특정 데이터 주변의 데이터도 곧 접근될 가능성이 높다는 원리입니다.
예: 배열의 요소들은 메모리에 연속적으로 저장되어 있어, 하나의 요소에 접근한 후 인접 요소들도 함께 캐시에 로드됩니다.

이 원리를 기반으로 캐시 메모리는 데이터를 블록 단위로 가져와 저장하며, 이를 통해 메모리 접근 효율성을 극대화합니다. 안드로이드 앱 개발 시 데이터 구조와 알고리즘을 설계할 때 이 원리를 고려하면 성능 향상에 도움이 됩니다.
```

3. **CPU 아키텍처의 종류(예: ARM, x86)와 각 특징에 대해 설명해주세요.**
```aiignore
CPU 아키텍처는 크게 ARM과 x86으로 나눌 수 있습니다:
ARM 아키텍처:

RISC(Reduced Instruction Set Computing) 기반으로 명령어 세트가 단순하고 최적화되어 있습니다.
저전력, 고효율 설계로 모바일 기기와 임베디드 시스템에 주로 사용됩니다.
안드로이드 스마트폰의 대부분이 ARM 기반 프로세서를 사용합니다.
라이선스 모델로 여러 제조사(퀄컴, 삼성, 애플 등)가 자체 프로세서를 설계할 수 있습니다.
최근에는 고성능 서버와 노트북(Apple M 시리즈)까지 영역을 확장하고 있습니다.

x86 아키텍처:

CISC(Complex Instruction Set Computing) 기반으로 복잡하고 다양한 명령어를 지원합니다.
인텔과 AMD가 주요 제조사입니다.
데스크톱, 노트북, 서버 등 고성능 컴퓨팅 환경에 주로 사용됩니다.
높은 성능을 제공하지만 상대적으로 전력 소모가 큽니다.
하위 호환성이 뛰어나 레거시 소프트웨어 지원이 잘 됩니다.

안드로이드 개발자 관점에서는 ARM 아키텍처에 대한 이해가 특히 중요하며, NDK를 통한 네이티브 코드 개발 시 타겟 아키텍처를 고려해야 합니다.
```

- 안드로이드 기기에서 주로 사용되는 CPU 아키텍처는 무엇인가요?
```aiignore
안드로이드 기기에서는 주로 ARM 아키텍처가 사용됩니다. 
ARM 프로세서는 저전력 고효율 설계로 모바일 기기에 적합하며, 대부분의 스마트폰과 태블릿에 탑재됩니다. 
ARM의 Cortex-A 시리즈가 주로 사용되고, 제조사별로 퀄컴의 스냅드래곤, 삼성의 엑시노스, 미디어텍의 헬리오 등 다양한 ARM 기반 프로세서가 있습니다. 
일부 저가형 모델이나 특수 목적 기기에서는 x86 아키텍처도 사용되지만, 시장 점유율은 ARM에 비해 매우 낮습니다.
```

4. **안드로이드 기기에서 사용되는 프로세서의 특징과 역할에 대해 설명해주세요.**
```aiignore
안드로이드 기기의 프로세서는 주로 다음과 같은 특징과 역할을 가집니다:
특징:
ARM 아키텍처 기반으로 모바일 환경에 최적화되어 있습니다.
SoC(System on Chip) 형태로 CPU, GPU, 모뎀, 신호 처리기 등이 하나의 칩에 통합되어 있습니다.
멀티코어 설계로 대부분 빅.리틀(big.LITTLE) 아키텍처를 채택하여 고성능 코어와 저전력 코어를 함께 사용합니다.
전력 효율성을 중시하여 배터리 사용 시간을 극대화합니다.

역할:
안드로이드 OS와 애플리케이션 실행의 핵심 연산을 처리합니다.
사용자 인터페이스 렌더링 및 멀티태스킹을 지원합니다.
AI 및 머신러닝 작업을 위한 전용 NPU(Neural Processing Unit)를 포함하는 경우가 많습니다.
카메라 처리, 오디오 처리 등 미디어 기능을 지원하는 전용 하드웨어를 통합합니다.
보안 기능을 위한 TEE(Trusted Execution Environment)를 제공합니다.
```
- SoC(System on a Chip)의 개념은 무엇인가요?
```aiignore
SoC(System on a Chip)는 하나의 집적회로에 컴퓨터나 전자기기에 필요한 여러 구성요소를 통합한 반도체 칩입니다. 
전통적으로 별도 칩으로 존재하던 CPU, GPU, 메모리 컨트롤러, 모뎀, 신호 처리기, 타이머, 입출력 인터페이스 등이 단일 칩에 통합되어 있습니다. 
이러한 통합 설계는 크기와 전력 소비를 줄이면서 성능은 향상시키는 장점이 있어 스마트폰, 태블릿과 같은 모바일 기기에 이상적입니다. 
안드로이드 기기에서는 퀄컴의 스냅드래곤, 삼성의 엑시노스, 미디어텍의 헬리오와 같은 SoC가 주로 사용됩니다.
```

5. **운영체제의 역할과 안드로이드 운영체제 구조에 대해 설명해주세요.**
```aiignore
운영체제의 역할:

하드웨어 자원 관리: CPU, 메모리, 저장 장치, 입출력 장치 등의 자원을 효율적으로 할당하고 관리합니다.
프로세스 관리: 애플리케이션 실행, 스케줄링, 프로세스 간 통신을 처리합니다.
파일 시스템 관리: 데이터 저장, 접근, 보안을 담당합니다.
사용자 인터페이스 제공: 사용자와 하드웨어 간의 상호작용을 가능하게 합니다.
보안 및 권한 관리: 시스템과 데이터의 보안을 유지합니다.

안드로이드 운영체제 구조:

리눅스 커널: 하드웨어 추상화 계층으로 드라이버, 메모리 관리, 프로세스 관리를 담당합니다.
하드웨어 추상화 계층(HAL): 하드웨어 기능을 상위 자바 API에 노출시키는 표준 인터페이스를 제공합니다.
안드로이드 런타임(ART): 자바 코드를 기기에서 실행할 수 있게 하는 가상 머신입니다.
네이티브 라이브러리: C/C++로 작성된 핵심 시스템 컴포넌트 라이브러리입니다.
자바 API 프레임워크: 앱 개발에 필요한 API 세트를 제공합니다.
시스템 앱: 기본 제공되는 이메일, SMS, 캘린더 등의 앱입니다.

이 계층화된 구조는 하드웨어 독립성과 보안을 강화하며, 다양한 기기에서 일관된 사용자 경험을 제공합니다.
```

- 안드로이드의 샌드박스 구조는 어떻게 동작하나요?
```aiignore
안드로이드의 샌드박스 구조는 애플리케이션 격리와 보안을 위한 핵심 메커니즘으로 다음과 같이 동작합니다:

프로세스 격리: 각 안드로이드 앱은 고유한 리눅스 사용자 ID(UID)와 별도의 프로세스에서 실행됩니다. 이를 통해 앱들이 서로의 데이터와 코드에 무단 접근하는 것을 방지합니다.
권한 기반 접근 제어: 앱이 시스템 리소스나 사용자 데이터에 접근하려면 명시적 권한이 필요합니다. 이 권한은 매니페스트에 선언되고, 민감한 권한은 사용자의 동의가 필요합니다.
애플리케이션 서명: 모든 앱은 개발자의 인증서로 디지털 서명되어야 합니다. 이를 통해 앱의 출처를 확인하고 무결성을 검증합니다.
앱별 저장소: 각 앱은 자체 내부 저장소를 가지며, 다른 앱은 기본적으로 이 공간에 접근할 수 없습니다.
컴포넌트 보안: 인텐트 필터, 컴포넌트 권한 등을 통해 앱 컴포넌트 간의 상호작용이 제어됩니다.

이러한 샌드박스 구조는 악성 앱의 영향을 제한하고, 앱 간 데이터 유출을 방지하며, 시스템 전체의 안정성을 향상시킵니다.
```

- 커널(Kernel)의 역할은 무엇인가요?
```aiignore
커널(Kernel)은 운영체제의 핵심 부분으로 다음과 같은 주요 역할을 수행합니다:

하드웨어 관리: 프로세서, 메모리, 디스크, 네트워크 장치 등 컴퓨터 하드웨어 자원을 직접 제어하고 관리합니다.
메모리 관리: 물리적 메모리와 가상 메모리를 할당하고 해제하며, 프로세스 간 메모리 보호를 제공합니다.
프로세스 관리: 프로세스 생성, 실행, 종료를 관리하고 CPU 스케줄링을 통해 프로세스 간 CPU 시간을 배분합니다.
디바이스 드라이버 관리: 하드웨어와 소프트웨어 간의 통신을 가능하게 하는 드라이버를 관리합니다.
시스템 호출 인터페이스: 애플리케이션이 하드웨어 자원에 접근할 수 있는 안전한 인터페이스를 제공합니다.
보안 및 권한 관리: 시스템 리소스에 대한 접근 권한을 제어하고 보안 정책을 시행합니다.

안드로이드에서는 리눅스 커널을 사용하여 이러한 기본 기능을 제공하고, 모바일 환경에 최적화된 추가 기능(예: 전원 관리, 공유 메모리, 바인더 IPC)을 포함합니다.
```
- 다중 태스킹(Multitasking)은 어떻게 지원되나요?
```aiignore
다중 태스킹(Multitasking)은 여러 프로세스가 동시에 실행되는 것처럼 보이도록 지원하는 메커니즘으로, 다음과 같이 구현됩니다:

프로세스 스케줄링: 운영체제의 스케줄러가 CPU 시간을 여러 프로세스에 할당합니다. 각 프로세스는 짧은 시간 동안 CPU를 사용한 후 다른 프로세스에게 전환됩니다.
선점형 멀티태스킹: 운영체제가 프로세스를 중단시키고 다른 프로세스를 실행할 수 있는 권한을 가집니다. 안드로이드는 이 방식을 사용하여 시스템 응답성을 유지합니다.
프로세스 상태 관리: 각 프로세스는 실행, 대기, 중단 등 다양한 상태를 가지며, 운영체제가 이를 관리합니다.
컨텍스트 스위칭: 한 프로세스에서 다른 프로세스로 전환할 때, CPU 레지스터와 상태 정보가 저장되고 복원되는 과정입니다.
우선순위 기반 실행: 프로세스마다 우선순위가 다르며, 높은 우선순위의 프로세스가 먼저 실행됩니다.

안드로이드에서는 추가적으로:

활동 매니저가 앱 간 전환을 관리합니다.
백그라운드 프로세스의 리소스 사용을 제한하여 포그라운드 앱의 성능을 보장합니다.
배터리 최적화를 위해 비활성 앱의 작업을 지연시키는 Doze와 App Standby 기능을 제공합니다.
```

6. **프로세스와 스레드의 차이점, 그리고 안드로이드에서의 프로세스와 스레드 관리 방법에 대해 설명해주세요.**
```aiignore
프로세스와 스레드의 차이점:

프로세스는 독립적인 실행 단위로, 자체 메모리 공간과 시스템 자원을 가집니다.
스레드는 프로세스 내에서 실행되는 더 작은 단위로, 같은 프로세스의 스레드들은 메모리 자원을 공유합니다.

안드로이드에서의 관리:

프로세스: 안드로이드는 메모리 부족 시 중요도에 따라 프로세스를 종료합니다. 활성 액티비티가 있는 프로세스는 높은 우선순위를 가집니다.
스레드: 메인 UI 스레드와 백그라운드 스레드로 나뉩니다. UI 작업은 메인 스레드에서, 네트워크나 DB 작업은 백그라운드 스레드에서 처리해야 합니다.

백그라운드 작업 관리:

AsyncTask(deprecated), Handler, Executor, Coroutines, WorkManager 등을 통해 백그라운드 작업을 처리합니다.
ANR(Application Not Responding) 방지를 위해 무거운 작업은 반드시 백그라운드 스레드로 처리해야 합니다.
```
- 멀티스레딩이 필요한 이유는 무엇인가요?
```aiignore
멀티스레딩이 필요한 이유:

반응성 향상: UI 스레드 블로킹 방지를 통해 사용자 경험을 원활하게 유지합니다. 무거운 작업 중에도 앱이 응답합니다.
성능 최적화: 여러 CPU 코어를 활용하여 병렬 처리가 가능해 전체 작업 처리 시간이 단축됩니다.
ANR 방지: 네트워크 요청, 파일 I/O, DB 작업 같은 시간이 걸리는 작업을 백그라운드에서 처리하여 ANR 다이얼로그 방지가 가능합니다.
효율적인 자원 활용: 한 스레드가 I/O 작업으로 대기 중일 때 다른 스레드가 CPU를 활용할 수 있어 자원 활용도가 높아집니다.
동시성 구현: 여러 기능(다운로드, 업로드, 캐싱 등)을 동시에 수행할 수 있습니다.
```
- 안드로이드에서 메인 스레드와 백그라운드 스레드의 차이점은 무엇인가요?
```aiignore
안드로이드에서 메인 스레드와 백그라운드 스레드의 차이점:

목적과 역할:
메인 스레드: UI 업데이트와 사용자 이벤트 처리를 담당하는 UI 스레드입니다.
백그라운드 스레드: 시간이 오래 걸리는 작업을 처리하여 메인 스레드 블로킹을 방지합니다.

제약사항:
메인 스레드: UI 요소는 오직 메인 스레드에서만 조작 가능합니다.
백그라운드 스레드: UI 직접 조작이 불가능하며, Handler나 runOnUiThread() 등을 통해 간접적으로만 UI 업데이트가 가능합니다.

블로킹:
메인 스레드: 5초 이상 블로킹 시 ANR 발생으로 앱이 강제 종료될 수 있습니다.
백그라운드 스레드: 오래 걸리는 작업을 수행해도 ANR이 발생하지 않습니다.

생성 방법:
메인 스레드: 앱 실행 시 자동으로 생성됩니다.
백그라운드 스레드: Thread, ExecutorService, Coroutines, WorkManager 등을 통해 명시적으로 생성합니다
```

7. **메모리 관리 기법 중 안드로이드에서 사용되는 방식과 그 특징에 대해 설명해주세요.**
```aiignore
안드로이드의 메모리 관리 기법과 특징:

가비지 컬렉션(GC):
ART/Dalvik VM이 자동으로 미사용 객체를 감지하고 회수합니다.
백그라운드에서 작동하지만, GC 실행 시 일시적인 성능 저하가 발생할 수 있습니다.

메모리 참조 관리:
강한 참조, 약한 참조, 소프트 참조를 통해 메모리 누수를 방지합니다.
특히 콜백 리스너, 이벤트 핸들러 등록 시 약한 참조 활용이 중요합니다.

앱 프로세스 생명주기:
안드로이드는 LMK(Low Memory Killer)를 통해 낮은 우선순위 프로세스부터 종료합니다.
포그라운드/백그라운드 상태에 따라 메모리 우선순위가 달라집니다.

메모리 제한:
앱별 힙 메모리 제한이 존재하며 기기마다 다릅니다.
대용량 비트맵 처리 시 메모리 효율성을 고려해야 합니다.

최적화 기법:
onTrimMemory() 콜백을 활용한 메모리 해제
SparseArray, ArrayMap 사용으로 메모리 효율성 향상
큰 객체는 필요할 때만 로드하고 사용 후 명시적 해제
```
- 가비지 컬렉션(Garbage Collection)은 어떻게 동작하나요?
```aiignore
가비지 컬렉션 동작 방식:

객체 식별:
Root Set(활성 스택 프레임, 정적 변수, 스레드, JNI 레퍼런스 등)에서 시작하여 참조 그래프 탐색
도달 가능한 객체는 살아있는 객체, 도달 불가능한 객체는 가비지로 판단

수집 단계:
Mark: 도달 가능한 객체를 표시
Sweep: 표시되지 않은 객체 메모리 회수
Compact: 필요시 메모리 단편화 해소를 위한 압축 수행

GC 유형:
Minor GC: Young Generation(새로 생성된 객체 영역)에서 빠르게 수행
Major/Full GC: 전체 힙 메모리에서 수행, 더 오래 걸리고 일시정지 현상 발생 가능

안드로이드 특징:
ART 런타임은 Concurrent GC를 도입해 애플리케이션 일시정지 시간 최소화
낮은 메모리 상황에서는 더 적극적으로 GC 수행
UI 스레드의 퍼포먼스에 영향을 줄 수 있어 메모리 관리가 중요

개발자 제어:
System.gc() 호출은 GC를 제안하지만 즉시 실행 보장 없음
불필요한 객체 참조 제거로 GC 효율 향상 가능
```
- 안드로이드의 메모리 누수(Memory Leak)는 어떤 경우에 발생하나요?
```aiignore
안드로이드의 메모리 누수 발생 케이스:

액티비티 참조 누수:
정적 변수나 싱글톤에서 액티비티를 강한 참조로 유지
백그라운드 스레드가 액티비티에 대한 참조를 유지하는 경우

내부 클래스 문제:
비정적 내부 클래스(익명 클래스 포함)는 외부 클래스 인스턴스에 대한 암시적 참조 보유
AsyncTask, Thread, Handler 등을 비정적 내부 클래스로 구현 시 누수 위험

콜백 및 리스너:
등록한 리스너를 명시적으로 해제하지 않는 경우
이벤트 버스, RxJava 구독 등을 적절히 해제하지 않는 경우

컨텍스트 참조:
생명주기가 긴 객체에 액티비티 컨텍스트를 저장하는 경우
어댑터나 뷰 홀더가 컨텍스트를 불필요하게 유지

자원 미해제:
Bitmap, Cursor, InputStream 등의 리소스를 명시적으로 close() 하지 않는 경우
onDestroy()에서 적절한 해제 코드 누락

브로드캐스트 리시버:
동적으로 등록된 리시버를 unregister하지 않는 경우
```

8. **안드로이드의 샌드박스(Sandbox) 개념과 역할, 그리고 앱 간 데이터 공유 방법에 대해 설명해주세요.**
```aiignore
안드로이드 샌드박스 개념과 역할:

정의:
각 앱은 독립된 프로세스에서 실행되며 고유한 리눅스 UID를 할당받습니다.
앱은 자신의 프라이빗 디렉토리와 리소스에만 접근 가능합니다.

보안 역할:
악성 앱으로부터 시스템과 다른 앱 보호
앱 간 데이터 무단 접근 방지
리소스 격리로 충돌과 간섭 최소화

앱 간 데이터 공유 방법:
ContentProvider:
구조화된 데이터 공유를 위한 표준 인터페이스
URI 기반으로 데이터 접근, CRUD 작업 지원
권한 제어 메커니즘 제공

Intent:
명시적/암시적 인텐트로 데이터 전송
소량 데이터는 extras로, 대용량은 URI 참조로 전달

FileProvider:
앱 간 파일 공유를 안전하게 지원
임시 권한 부여 메커니즘 제공

SharedPreferences:
MODE_WORLD_READABLE, MODE_WORLD_WRITEABLE(Android N 이후 지원 중단)

공유 저장소:
MediaStore API를 통한 미디어 파일 공유
Storage Access Framework로 사용자 선택 기반 파일 접근

IPC 메커니즘:
AIDL(Android Interface Definition Language)
Messenger, Binder 활용
```
- 인텐트(Intent)를 이용한 앱 간 통신은 어떻게 이루어지나요?
```aiignore
인텐트를 이용한 앱 간 통신:

인텐트 유형:
명시적 인텐트: 특정 컴포넌트를 지정하여 직접 호출 (주로 앱 내부 통신)
암시적 인텐트: 작업 유형만 선언하고 시스템이 적합한 앱 결정 (앱 간 통신에 활용)

통신 과정:
발신 앱: 인텐트 객체 생성, 액션/데이터/카테고리 설정, 필요 시 extras 데이터 추가
안드로이드 시스템: 인텐트 필터와 매칭되는 컴포넌트 검색
수신 앱: 인텐트를 받아 처리하고 필요시 결과 반환

데이터 공유:
기본 타입, Serializable, Parcelable 객체를 extras로 전달
URI를 통한 콘텐트 프로바이더 데이터 참조
대용량 데이터는 FileProvider 활용

결과 수신:
startActivityForResult() 호출 (deprecated)
ActivityResultLauncher API 사용 (현재 권장)
응답은 onActivityResult() 또는 콜백으로 수신


보안 고려사항:
민감한 데이터 전송 시 명시적 인텐트 사용 권장
인텐트 필터 설정으로 원치 않는 외부 접근 제한
필요시 custom permissions 정의
```
- 콘텐트 프로바이더(Content Provider)를 활용하여 데이터 공유를 하는 방법은 무엇인가요?
```aiignore
콘텐트 프로바이더 데이터 공유 방법:

제공자(Provider) 구현:
ContentProvider 클래스 상속
URI authority 정의 (예: "com.example.app.provider")
CRUD 메서드(query, insert, update, delete) 구현
manifest에 provider 등록 및 권한 설정

데이터 구조 정의:
테이블 구조와 컬럼 정의를 위한 Contract 클래스 생성
URI 매칭을 위한 UriMatcher 활용
MIME 타입 정의로 반환 데이터 유형 명시

클라이언트(Consumer) 접근:
ContentResolver 객체를 통한 데이터 요청
URI 기반으로 데이터 식별 (예: "content://com.example.app.provider/items/123")
Cursor 객체로 반환된 데이터 처리

권한 관리:
읽기/쓰기 권한 분리 설정 가능
매니페스트에 권한 선언, 클라이언트는 해당 권한 요청
임시 URI 권한 부여 가능 (grantUriPermission)


변경 알림:
notifyChange()로 데이터 변경 시 등록된 옵저버에 알림
ContentObserver 등록으로 변경 감지 및 UI 업데이트
```

9. **안드로이드에서의 메모리 구조와 관리 방식에 대해 자세히 설명해주세요.**
```aiignore
안드로이드 메모리 구조와 관리 방식:

메모리 아키텍처:
Dalvik/ART VM 기반의 힙 메모리 관리
각 앱은 독립된 프로세스에서 실행되며 고유한 VM 인스턴스 보유
기기별 앱당 힙 메모리 제한 존재 (16MB~512MB, 기기마다 상이)

메모리 영역 구분:
Young Generation: 새로 생성된 객체, Minor GC로 자주 정리
Old Generation: 오래 생존한 객체, Major GC로 정리
네이티브 힙: JNI를 통한 C/C++ 코드용 메모리

저수준 메모리 관리:
리눅스 커널의 메모리 관리 메커니즘 활용
Low Memory Killer(LMK)가 메모리 부족 시 우선순위가 낮은 프로세스 종료
OOM(Out Of Memory) 예외 발생 시 앱 강제 종료

프로세스 우선순위:
포그라운드: 사용자와 상호작용 중인 액티비티
가시적: 화면에 보이지만 포커스 없는 프로세스
서비스: 백그라운드에서 실행 중인 서비스
백그라운드: 보이지 않는 액티비티를 가진 프로세스
빈 프로세스: 활성 컴포넌트 없이 캐시로 유지

개발자 도구:
Memory Profiler로 실시간 메모리 사용량 모니터링
Leak Canary 등의 라이브러리로 메모리 누수 감지
Heap dumps 분석으로 문제 객체 식별

최적화 기술:
메모리 효율적인 데이터 구조 사용 (SparseArray, ArrayMap)
비트맵 리사이징 및 캐싱 전략
onTrimMemory() 콜백에서 메모리 해제 로직 구현
```
- 힙(Heap)과 스택(Stack)의 차이점은 무엇인가요?
```aiignore
힙과 스택의 차이점:

메모리 할당 방식:
스택: 컴파일 시간에 크기가 결정되는 정적 할당. LIFO(Last In First Out) 구조로 함수 호출 스택 유지
힙: 런타임에 동적으로 할당되는 메모리 영역. 필요할 때 할당하고 더 이상 필요 없을 때 해제

저장 데이터:
스택: 지역 변수, 함수 파라미터, 리턴 주소 등 임시 데이터
힙: 객체, 인스턴스 변수 등 동적으로 생성되는 데이터

메모리 관리:
스택: 함수 호출 종료 시 자동으로 메모리 해제
힙: 명시적 해제(C/C++) 또는 가비지 컬렉션(Java/Kotlin)으로 관리

액세스 속도:
스택: CPU에 가깝고 구조가 단순하여 빠른 액세스
힙: 관리 오버헤드와 단편화로 인해 상대적으로 느린 액세스

크기 제한:
스택: 제한된 크기 (안드로이드에서 일반적으로 스레드당 8MB)
힙: 더 큰 크기 가능 (앱 전체에서 사용 가능한 메모리 풀)

안드로이드 특성:
스택 오버플로우: 재귀 호출이 깊거나 큰 로컬 변수 선언 시 발생
힙 메모리 부족: OOM(Out Of Memory) 예외로 나타남
```
- 안드로이드 앱의 메모리 제한은 어떻게 설정되나요?
```aiignore
안드로이드 앱 메모리 제한:

기기 및 OS 종속적:
기기의 총 RAM에 따라 앱당 힙 크기 제한이 결정됩니다
저사양 기기는 16MB, 고사양 기기는 512MB 이상까지 다양

매니페스트 설정:
android:largeHeap="true" 속성으로 더 큰 힙 요청 가능
그러나 실제 증가량은 시스템이 결정하며 무제한은 아님

NDK 애플리케이션:
네이티브 힙은 별도로 관리되어 자바 힙 제한에 포함되지 않음
단, 전체 프로세스 메모리 제한은 여전히 적용됨

런타임 확인:
ActivityManager.getMemoryClass()로 현재 앱의 힙 제한 확인(MB 단위)
ActivityManager.getLargeMemoryClass()로 largeHeap 설정 시 제한 확인

제한 관리 메커니즘:
앱이 할당된 메모리 한계에 도달하면 OOM 예외 발생
시스템 전체 메모리 부족 시 LMK(Low Memory Killer)가 우선순위가 낮은 프로세스부터 종료

모니터링:
Runtime.getRuntime().maxMemory()로 최대 힙 메모리 확인
Runtime.getRuntime().totalMemory()와 freeMemory()로 현재 사용량 추적
```

10. **네트워크 프로토콜 스택과 안드로이드에서의 네트워크 통신 방식에 대해 설명해주세요.**
```aiignore
네트워크 프로토콜 스택:
1. 계층 구조:
   - 물리층: 실제 하드웨어 및 전기 신호
   - 데이터링크층: MAC 주소 기반 통신, 프레임 단위 전송
   - 네트워크층: IP 주소 기반 라우팅, 패킷 단위 전송
   - 전송층: TCP/UDP를 통한 연결 관리, 신뢰성 보장
   - 응용층: HTTP, HTTPS, FTP 등 애플리케이션 프로토콜

안드로이드 네트워크 통신 방식:
1. 기본 API:
   - HttpURLConnection: 기본 내장 HTTP 클라이언트
   - Socket 클래스: 저수준 TCP/UDP 통신 지원
   
2. 고수준 라이브러리:
   - Retrofit: 선언적 REST API 인터페이스 제공
   - OkHttp: 효율적인 HTTP 클라이언트, 캐싱, 재시도 지원
   - Volley: 요청 큐 및 우선순위 관리 기능 제공

3. 웹소켓/실시간 통신:
   - WebSocket: 양방향 실시간 통신 지원
   - Firebase Realtime Database: 클라우드 기반 실시간 데이터 동기화

4. 네트워크 관련 고려사항:
   - 메인 스레드에서 네트워크 작업 금지 (NetworkOnMainThreadException)
   - ConnectivityManager로 네트워크 상태 모니터링
   - 안드로이드 9(Pie) 이후 기본적으로 HTTPS 강제화

5. 권한 관리:
   - INTERNET 권한: 네트워크 접근 필수 권한
   - ACCESS_NETWORK_STATE: 네트워크 상태 확인 권한
```
- 안드로이드에서 네트워크 요청을 처리하는 라이브러리는 어떤 것들이 있나요?
```aiignore
안드로이드 네트워크 요청 처리 라이브러리:

1. Retrofit:
   - 선언적 REST API 인터페이스 설계
   - 애노테이션 기반 API 엔드포인트 정의
   - RxJava, Coroutines와 통합 용이
   - 자동 JSON/XML 변환 (Gson, Moshi, Jackson 등과 함께 사용)

2. OkHttp:
   - 효율적인 HTTP 클라이언트 (Retrofit의 기본 네트워크 엔진)
   - 연결 풀링, 응답 캐싱, 요청 재시도 기능
   - HTTP/2 및 SPDY 지원
   - 인터셉터를 통한 요청/응답 커스터마이징

3. Volley:
   - 구글이 개발한 네트워크 라이브러리
   - 요청 큐 및 우선순위 관리
   - 메모리 효율적인 이미지 로딩
   - 디스크 및 메모리 캐싱 내장

4. Ktor Client:
   - Kotlin 멀티플랫폼 네트워크 라이브러리
   - Coroutines 기반 비동기 처리
   - 다양한 직렬화 옵션 제공
   - 플러그인 기반 아키텍처로 확장성 높음

5. Apollo:
   - GraphQL 특화 클라이언트
   - 코드 생성을 통한 타입 안전성 제공
   - 캐싱 및 실시간 구독 지원

6. HttpURLConnection:
   - 안드로이드 기본 내장 API
   - 외부 의존성 없이 사용 가능
   - 저수준 제어 가능
```